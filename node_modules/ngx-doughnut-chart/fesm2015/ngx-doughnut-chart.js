import { Injectable, NgModule, Component, Input, defineInjectable } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgxDonutChartService {
    constructor() { }
}
NgxDonutChartService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
];
/** @nocollapse */
NgxDonutChartService.ctorParameters = () => [];
/** @nocollapse */ NgxDonutChartService.ngInjectableDef = defineInjectable({ factory: function NgxDonutChartService_Factory() { return new NgxDonutChartService(); }, token: NgxDonutChartService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgxDonutChartComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setDefaults();
        /** @type {?} */
        let angles = this._calculateAngles(this.data);
        /** @type {?} */
        let ArchPoints = this._calculateArcPoints(this.data);
    }
    /**
     * @return {?}
     */
    setDefaults() {
        this.arcs = [];
        this.radius = this.radius || 200;
        this.margin = this.margin || 10;
        this.thickness = this.thickness || 8;
        this.totalClass = this.totalClass || 'c-donutchart__title';
        this.origin = {
            x: this.radius,
            y: this.radius,
        };
        this.width = ((2 * this.radius) + (2 * this.margin)) + 'px';
        this.height = ((2 * this.radius) + (2 * this.margin)) + 'px';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    _calculateArcPoints(data) {
        /** @type {?} */
        let archPoints = [];
        archPoints.push({
            x: this.radius,
            y: 0,
        });
        /** @type {?} */
        let startAngle = 0;
        /** @type {?} */
        let endAngle;
        /** @type {?} */
        let startX = this.origin.x;
        /** @type {?} */
        let startY = this.origin.y;
        for (let item of data) {
            endAngle = (startAngle + item.angle) % 360;
            startAngle += 8;
            /** @type {?} */
            let arc = this._describeArc(startX, startY, this.radius, startAngle, endAngle, item.color);
            this.arcs.push(arc);
            startAngle = endAngle;
        }
    }
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} radius
     * @param {?} startAngle
     * @param {?} endAngle
     * @param {?} color
     * @return {?}
     */
    _describeArc(x, y, radius, startAngle, endAngle, color) {
        /** @type {?} */
        let start = this._polarToCartesian(x, y, radius, startAngle);
        /** @type {?} */
        let end = this._polarToCartesian(x, y, radius, endAngle);
        /** @type {?} */
        let arcSweep = endAngle - startAngle <= 180 ? "0" : "1";
        /** @type {?} */
        let d = [
            "M", start.x, start.y,
            "A", radius, radius, 0, arcSweep, 1, end.x, end.y,
        ].join(" ");
        return {
            d: d,
            end: end,
            color: color,
        };
    }
    /**
     * @param {?} data
     * @return {?}
     */
    _calculateAngles(data) {
        /** @type {?} */
        let angles = [];
        /** @type {?} */
        let total = this._getTotal(data);
        this.total = total;
        for (let i = 0; i < data.length; i++) {
            /** @type {?} */
            let dataItem = data[i];
            /** @type {?} */
            let angle = (dataItem.value / total) * 360.0;
            dataItem.angle = angle;
            dataItem.percentage = ((dataItem.value / total) * 100.0).toFixed(2) + '%';
            angles.push(angle);
        }
        return angles;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    _getTotal(data) {
        return data.reduce((a, b) => ({ value: a.value + b.value })).value;
    }
    /**
     * @param {?} centerX
     * @param {?} centerY
     * @param {?} radius
     * @param {?} angleInDegrees
     * @return {?}
     */
    _polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        /** @type {?} */
        let angleInRadians = (angleInDegrees) * Math.PI / 180.0;
        return {
            x: centerX + (radius * Math.cos(angleInRadians)) + this.margin,
            y: centerY + (radius * Math.sin(angleInRadians)) + this.margin,
        };
    }
}
NgxDonutChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-donut-chart',
                template: `<div
  class="c-donutchart"
  [ngStyle]="{'width': width}">
  <svg
    [ngStyle]="{'width': width, 'height': height}"
    xmlns="http://www.w3.org/2000/svg">
    <!-- <path [attr.d]="pathD" stroke="black" fill="transparent" stroke-width="8" fill-opacity="0.5"/> -->
    <path
      *ngFor="let arc of arcs"
      [attr.d]="arc.d"
      [attr.stroke]="arc.color"
      fill="transparent"
      [attr.stroke-width]="thickness"
      fill-opacity="0.5"/>
  </svg>

  <div
    class="c-donutchart__text"
    *ngIf="title"
    [ngStyle]="{'width': width, 'height': height}">
    <div
      [ngClass]="totalClass"
      [innerText]="total"></div>
    <div [innerText]="title"></div>
  </div>

  <div class="c-donutchart__legends">
    <div
      class="c-donutchart__legend"
      *ngFor="let item of data">
      <div
        class="c-donutchart__legend-bar"
        [ngStyle]="{'background-color': item.color}">
      </div>

      <div
        class="c-donutchart__legend-title"
        [innerText]="item.label">
      </div>

      <div
        class="c-donutchart__legend-percentage"
        [innerText]="item.percentage">
      </div>
    </div>
  </div>
</div>
`,
                styles: [`.c-donutchart{position:relative}.c-donutchart .c-donutchart__text{position:absolute;top:0;left:0;display:flex;flex-flow:column;align-items:center;justify-content:center}.c-donutchart .c-donutchart__title{font-size:40px}.c-donutchart .c-donutchart__legends{display:flex;justify-content:center}.c-donutchart .c-donutchart__legend{display:flex;flex-flow:column;align-items:center;margin:16px 8px}.c-donutchart .c-donutchart__legend-bar{display:flex;align-items:center;justify-content:center;margin-bottom:8px;width:40px;height:8px;border-radius:4px;background-color:#dc143c}.c-donutchart .c-donutchart__legend-percentage,.c-donutchart .c-donutchart__legend-title{text-align:center}`]
            },] },
];
/** @nocollapse */
NgxDonutChartComponent.ctorParameters = () => [];
NgxDonutChartComponent.propDecorators = {
    data: [{ type: Input }],
    radius: [{ type: Input }],
    margin: [{ type: Input }],
    title: [{ type: Input }],
    thickness: [{ type: Input }],
    totalClass: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgxDonutChartModule {
}
NgxDonutChartModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [NgxDonutChartComponent],
                exports: [NgxDonutChartComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgxDonutChartService, NgxDonutChartComponent, NgxDonutChartModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWRvdWdobnV0LWNoYXJ0LmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9uZ3gtZG91Z2hudXQtY2hhcnQvbGliL25neC1kb251dC1jaGFydC5zZXJ2aWNlLnRzIiwibmc6Ly9uZ3gtZG91Z2hudXQtY2hhcnQvbGliL25neC1kb251dC1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL25neC1kb3VnaG51dC1jaGFydC9saWIvbmd4LWRvbnV0LWNoYXJ0Lm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIE5neERvbnV0Q2hhcnRTZXJ2aWNlIHtcblxuICBjb25zdHJ1Y3RvcigpIHsgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25neC1kb251dC1jaGFydCcsXG4gIHRlbXBsYXRlOiBgPGRpdlxuICBjbGFzcz1cImMtZG9udXRjaGFydFwiXG4gIFtuZ1N0eWxlXT1cInsnd2lkdGgnOiB3aWR0aH1cIj5cbiAgPHN2Z1xuICAgIFtuZ1N0eWxlXT1cInsnd2lkdGgnOiB3aWR0aCwgJ2hlaWdodCc6IGhlaWdodH1cIlxuICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICA8IS0tIDxwYXRoIFthdHRyLmRdPVwicGF0aERcIiBzdHJva2U9XCJibGFja1wiIGZpbGw9XCJ0cmFuc3BhcmVudFwiIHN0cm9rZS13aWR0aD1cIjhcIiBmaWxsLW9wYWNpdHk9XCIwLjVcIi8+IC0tPlxuICAgIDxwYXRoXG4gICAgICAqbmdGb3I9XCJsZXQgYXJjIG9mIGFyY3NcIlxuICAgICAgW2F0dHIuZF09XCJhcmMuZFwiXG4gICAgICBbYXR0ci5zdHJva2VdPVwiYXJjLmNvbG9yXCJcbiAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXG4gICAgICBbYXR0ci5zdHJva2Utd2lkdGhdPVwidGhpY2tuZXNzXCJcbiAgICAgIGZpbGwtb3BhY2l0eT1cIjAuNVwiLz5cbiAgPC9zdmc+XG5cbiAgPGRpdlxuICAgIGNsYXNzPVwiYy1kb251dGNoYXJ0X190ZXh0XCJcbiAgICAqbmdJZj1cInRpdGxlXCJcbiAgICBbbmdTdHlsZV09XCJ7J3dpZHRoJzogd2lkdGgsICdoZWlnaHQnOiBoZWlnaHR9XCI+XG4gICAgPGRpdlxuICAgICAgW25nQ2xhc3NdPVwidG90YWxDbGFzc1wiXG4gICAgICBbaW5uZXJUZXh0XT1cInRvdGFsXCI+PC9kaXY+XG4gICAgPGRpdiBbaW5uZXJUZXh0XT1cInRpdGxlXCI+PC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxkaXYgY2xhc3M9XCJjLWRvbnV0Y2hhcnRfX2xlZ2VuZHNcIj5cbiAgICA8ZGl2XG4gICAgICBjbGFzcz1cImMtZG9udXRjaGFydF9fbGVnZW5kXCJcbiAgICAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGRhdGFcIj5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJjLWRvbnV0Y2hhcnRfX2xlZ2VuZC1iYXJcIlxuICAgICAgICBbbmdTdHlsZV09XCJ7J2JhY2tncm91bmQtY29sb3InOiBpdGVtLmNvbG9yfVwiPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJjLWRvbnV0Y2hhcnRfX2xlZ2VuZC10aXRsZVwiXG4gICAgICAgIFtpbm5lclRleHRdPVwiaXRlbS5sYWJlbFwiPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJjLWRvbnV0Y2hhcnRfX2xlZ2VuZC1wZXJjZW50YWdlXCJcbiAgICAgICAgW2lubmVyVGV4dF09XCJpdGVtLnBlcmNlbnRhZ2VcIj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgc3R5bGVzOiBbYC5jLWRvbnV0Y2hhcnR7cG9zaXRpb246cmVsYXRpdmV9LmMtZG9udXRjaGFydCAuYy1kb251dGNoYXJ0X190ZXh0e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtkaXNwbGF5OmZsZXg7ZmxleC1mbG93OmNvbHVtbjthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uYy1kb251dGNoYXJ0IC5jLWRvbnV0Y2hhcnRfX3RpdGxle2ZvbnQtc2l6ZTo0MHB4fS5jLWRvbnV0Y2hhcnQgLmMtZG9udXRjaGFydF9fbGVnZW5kc3tkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uYy1kb251dGNoYXJ0IC5jLWRvbnV0Y2hhcnRfX2xlZ2VuZHtkaXNwbGF5OmZsZXg7ZmxleC1mbG93OmNvbHVtbjthbGlnbi1pdGVtczpjZW50ZXI7bWFyZ2luOjE2cHggOHB4fS5jLWRvbnV0Y2hhcnQgLmMtZG9udXRjaGFydF9fbGVnZW5kLWJhcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luLWJvdHRvbTo4cHg7d2lkdGg6NDBweDtoZWlnaHQ6OHB4O2JvcmRlci1yYWRpdXM6NHB4O2JhY2tncm91bmQtY29sb3I6I2RjMTQzY30uYy1kb251dGNoYXJ0IC5jLWRvbnV0Y2hhcnRfX2xlZ2VuZC1wZXJjZW50YWdlLC5jLWRvbnV0Y2hhcnQgLmMtZG9udXRjaGFydF9fbGVnZW5kLXRpdGxle3RleHQtYWxpZ246Y2VudGVyfWBdXG59KVxuZXhwb3J0IGNsYXNzIE5neERvbnV0Q2hhcnRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICBASW5wdXQoKSBkYXRhOiBbe2FueX1dO1xuICBASW5wdXQoKSByYWRpdXM6IG51bWJlcjtcbiAgQElucHV0KCkgbWFyZ2luOiBudW1iZXI7XG4gIEBJbnB1dCgpIHRpdGxlOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHRoaWNrbmVzczogbnVtYmVyO1xuICBASW5wdXQoKSB0b3RhbENsYXNzOiBzdHJpbmc7XG4gIHdpZHRoOiBzdHJpbmc7XG4gIGhlaWdodDogc3RyaW5nO1xuICBvcmlnaW46IHt4OiBudW1iZXIsIHk6IG51bWJlcn07XG4gIGFyY3M6IGFueVtdO1xuICB0b3RhbDogbnVtYmVyO1xuICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc2V0RGVmYXVsdHMoKTtcbiAgICBsZXQgYW5nbGVzID0gdGhpcy5fY2FsY3VsYXRlQW5nbGVzKHRoaXMuZGF0YSk7XG4gICAgbGV0IEFyY2hQb2ludHMgPSB0aGlzLl9jYWxjdWxhdGVBcmNQb2ludHModGhpcy5kYXRhKTtcbiAgfVxuXG4gIHNldERlZmF1bHRzKCkge1xuICAgIHRoaXMuYXJjcyA9IFtdO1xuICAgIHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgfHwgMjAwO1xuICAgIHRoaXMubWFyZ2luID0gdGhpcy5tYXJnaW4gfHwgMTA7XG4gICAgdGhpcy50aGlja25lc3MgPSB0aGlzLnRoaWNrbmVzcyB8fCA4O1xuICAgIHRoaXMudG90YWxDbGFzcyA9IHRoaXMudG90YWxDbGFzcyB8fCAnYy1kb251dGNoYXJ0X190aXRsZSc7XG4gICAgdGhpcy5vcmlnaW4gPSB7XG4gICAgICB4OiB0aGlzLnJhZGl1cyxcbiAgICAgIHk6IHRoaXMucmFkaXVzLFxuICAgIH07XG4gICAgdGhpcy53aWR0aCA9ICgoMiAqIHRoaXMucmFkaXVzKSArICgyICogdGhpcy5tYXJnaW4pKSArICdweCc7XG4gICAgdGhpcy5oZWlnaHQgPSAoKDIgKiB0aGlzLnJhZGl1cykgKyAoMiAqIHRoaXMubWFyZ2luKSkgKyAncHgnO1xuICB9XG5cbiAgX2NhbGN1bGF0ZUFyY1BvaW50cyhkYXRhKSB7XG4gICAgbGV0IGFyY2hQb2ludHMgPSBbXTtcbiAgICBhcmNoUG9pbnRzLnB1c2goe1xuICAgICAgeDogdGhpcy5yYWRpdXMsXG4gICAgICB5OiAwLFxuICAgIH0pO1xuXG4gICAgbGV0IHN0YXJ0QW5nbGUgPSAwO1xuICAgIGxldCBlbmRBbmdsZTtcbiAgICBsZXQgc3RhcnRYID0gdGhpcy5vcmlnaW4ueDtcbiAgICBsZXQgc3RhcnRZID0gdGhpcy5vcmlnaW4ueTtcblxuICAgIGZvciAobGV0IGl0ZW0gb2YgZGF0YSkge1xuICAgICAgZW5kQW5nbGUgPSAoc3RhcnRBbmdsZSArIGl0ZW0uYW5nbGUpICUgMzYwO1xuICAgICAgc3RhcnRBbmdsZSArPSA4O1xuICAgICAgLy8gZW5kQW5nbGUgLT01O1xuXG4gICAgICBsZXQgYXJjID0gdGhpcy5fZGVzY3JpYmVBcmMoc3RhcnRYLCBzdGFydFksIHRoaXMucmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaXRlbS5jb2xvcik7XG4gICAgICB0aGlzLmFyY3MucHVzaChhcmMpO1xuXG4gICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgfVxuICB9XG5cbiAgX2Rlc2NyaWJlQXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvbG9yKXtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLl9wb2xhclRvQ2FydGVzaWFuKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSk7XG4gICAgbGV0IGVuZCA9IHRoaXMuX3BvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBlbmRBbmdsZSk7XG4gICAgbGV0IGFyY1N3ZWVwID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlIDw9IDE4MCA/IFwiMFwiIDogXCIxXCI7XG5cbiAgICBsZXQgZCA9IFtcbiAgICAgICAgXCJNXCIsIHN0YXJ0LngsIHN0YXJ0LnksXG4gICAgICAgIFwiQVwiLCByYWRpdXMsIHJhZGl1cywgMCwgYXJjU3dlZXAsIDEsIGVuZC54LCBlbmQueSxcbiAgICAgICAgLy8gXCJMXCIsIHgseSxcbiAgICAgICAgLy8gXCJMXCIsIHN0YXJ0LngsIHN0YXJ0LnlcbiAgICBdLmpvaW4oXCIgXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGQ6IGQsXG4gICAgICBlbmQ6IGVuZCxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICB9O1xuICB9XG5cbiAgX2NhbGN1bGF0ZUFuZ2xlcyhkYXRhKSB7XG4gICAgbGV0IGFuZ2xlcyA9IFtdO1xuICAgIGxldCB0b3RhbCA9IHRoaXMuX2dldFRvdGFsKGRhdGEpO1xuICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGRhdGFJdGVtID0gZGF0YVtpXTtcbiAgICAgIGxldCBhbmdsZSA9IChkYXRhSXRlbS52YWx1ZSAvIHRvdGFsKSAqIDM2MC4wO1xuICAgICAgZGF0YUl0ZW0uYW5nbGUgPSBhbmdsZTtcbiAgICAgIGRhdGFJdGVtLnBlcmNlbnRhZ2UgPSAoKGRhdGFJdGVtLnZhbHVlIC8gdG90YWwpICogMTAwLjApLnRvRml4ZWQoMikgKyAnJSc7XG4gICAgICBhbmdsZXMucHVzaChhbmdsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuZ2xlcztcbiAgfVxuXG4gIF9nZXRUb3RhbChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucmVkdWNlKChhLCBiKSA9PiAoeyB2YWx1ZSA6IGEudmFsdWUgKyBiLnZhbHVlIH0pKS52YWx1ZTtcbiAgfVxuXG4gIF9wb2xhclRvQ2FydGVzaWFuKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgYW5nbGVJbkRlZ3JlZXMpIHtcbiAgICBsZXQgYW5nbGVJblJhZGlhbnMgPSAoYW5nbGVJbkRlZ3JlZXMpICogTWF0aC5QSSAvIDE4MC4wO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGNlbnRlclggKyAocmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpKSArIHRoaXMubWFyZ2luLFxuICAgICAgeTogY2VudGVyWSArIChyYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucykpICsgdGhpcy5tYXJnaW4sXG4gICAgfTtcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgTmd4RG9udXRDaGFydENvbXBvbmVudCB9IGZyb20gJy4vbmd4LWRvbnV0LWNoYXJ0LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGVcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbTmd4RG9udXRDaGFydENvbXBvbmVudF0sXG4gIGV4cG9ydHM6IFtOZ3hEb251dENoYXJ0Q29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBOZ3hEb251dENoYXJ0TW9kdWxlIHsgfVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtJQU9FLGlCQUFpQjs7O1lBTGxCLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7Ozs7Ozs7OztBQ0pEO0lBa0VFLGlCQUFpQjs7OztJQUVqQixRQUFRO1FBQ04sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDOztRQUNuQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztRQUM5QyxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3REOzs7O0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2YsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLEdBQUcsQ0FBQztRQUNqQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxJQUFJLHFCQUFxQixDQUFDO1FBQzNELElBQUksQ0FBQyxNQUFNLEdBQUc7WUFDWixDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDZCxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU07U0FDZixDQUFDO1FBQ0YsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUM7UUFDNUQsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUM7S0FDOUQ7Ozs7O0lBRUQsbUJBQW1CLENBQUMsSUFBSTs7UUFDdEIsSUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLFVBQVUsQ0FBQyxJQUFJLENBQUM7WUFDZCxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDZCxDQUFDLEVBQUUsQ0FBQztTQUNMLENBQUMsQ0FBQzs7UUFFSCxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7O1FBQ25CLElBQUksUUFBUSxDQUFDOztRQUNiLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDOztRQUMzQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUUzQixLQUFLLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtZQUNyQixRQUFRLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxHQUFHLENBQUM7WUFDM0MsVUFBVSxJQUFJLENBQUMsQ0FBQzs7WUFHaEIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDM0YsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFD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
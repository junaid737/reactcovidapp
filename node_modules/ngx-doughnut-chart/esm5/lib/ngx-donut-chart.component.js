/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Input } from '@angular/core';
var NgxDonutChartComponent = /** @class */ (function () {
    function NgxDonutChartComponent() {
    }
    /**
     * @return {?}
     */
    NgxDonutChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setDefaults();
        /** @type {?} */
        var angles = this._calculateAngles(this.data);
        /** @type {?} */
        var ArchPoints = this._calculateArcPoints(this.data);
    };
    /**
     * @return {?}
     */
    NgxDonutChartComponent.prototype.setDefaults = /**
     * @return {?}
     */
    function () {
        this.arcs = [];
        this.radius = this.radius || 200;
        this.margin = this.margin || 10;
        this.thickness = this.thickness || 8;
        this.totalClass = this.totalClass || 'c-donutchart__title';
        this.origin = {
            x: this.radius,
            y: this.radius,
        };
        this.width = ((2 * this.radius) + (2 * this.margin)) + 'px';
        this.height = ((2 * this.radius) + (2 * this.margin)) + 'px';
    };
    /**
     * @param {?} data
     * @return {?}
     */
    NgxDonutChartComponent.prototype._calculateArcPoints = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var archPoints = [];
        archPoints.push({
            x: this.radius,
            y: 0,
        });
        /** @type {?} */
        var startAngle = 0;
        /** @type {?} */
        var endAngle;
        /** @type {?} */
        var startX = this.origin.x;
        /** @type {?} */
        var startY = this.origin.y;
        try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var item = data_1_1.value;
                endAngle = (startAngle + item.angle) % 360;
                startAngle += 8;
                /** @type {?} */
                var arc = this._describeArc(startX, startY, this.radius, startAngle, endAngle, item.color);
                this.arcs.push(arc);
                startAngle = endAngle;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var e_1, _a;
    };
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} radius
     * @param {?} startAngle
     * @param {?} endAngle
     * @param {?} color
     * @return {?}
     */
    NgxDonutChartComponent.prototype._describeArc = /**
     * @param {?} x
     * @param {?} y
     * @param {?} radius
     * @param {?} startAngle
     * @param {?} endAngle
     * @param {?} color
     * @return {?}
     */
    function (x, y, radius, startAngle, endAngle, color) {
        /** @type {?} */
        var start = this._polarToCartesian(x, y, radius, startAngle);
        /** @type {?} */
        var end = this._polarToCartesian(x, y, radius, endAngle);
        /** @type {?} */
        var arcSweep = endAngle - startAngle <= 180 ? "0" : "1";
        /** @type {?} */
        var d = [
            "M", start.x, start.y,
            "A", radius, radius, 0, arcSweep, 1, end.x, end.y,
        ].join(" ");
        return {
            d: d,
            end: end,
            color: color,
        };
    };
    /**
     * @param {?} data
     * @return {?}
     */
    NgxDonutChartComponent.prototype._calculateAngles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var angles = [];
        /** @type {?} */
        var total = this._getTotal(data);
        this.total = total;
        for (var i = 0; i < data.length; i++) {
            /** @type {?} */
            var dataItem = data[i];
            /** @type {?} */
            var angle = (dataItem.value / total) * 360.0;
            dataItem.angle = angle;
            dataItem.percentage = ((dataItem.value / total) * 100.0).toFixed(2) + '%';
            angles.push(angle);
        }
        return angles;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    NgxDonutChartComponent.prototype._getTotal = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.reduce(function (a, b) { return ({ value: a.value + b.value }); }).value;
    };
    /**
     * @param {?} centerX
     * @param {?} centerY
     * @param {?} radius
     * @param {?} angleInDegrees
     * @return {?}
     */
    NgxDonutChartComponent.prototype._polarToCartesian = /**
     * @param {?} centerX
     * @param {?} centerY
     * @param {?} radius
     * @param {?} angleInDegrees
     * @return {?}
     */
    function (centerX, centerY, radius, angleInDegrees) {
        /** @type {?} */
        var angleInRadians = (angleInDegrees) * Math.PI / 180.0;
        return {
            x: centerX + (radius * Math.cos(angleInRadians)) + this.margin,
            y: centerY + (radius * Math.sin(angleInRadians)) + this.margin,
        };
    };
    NgxDonutChartComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-donut-chart',
                    template: "<div\n  class=\"c-donutchart\"\n  [ngStyle]=\"{'width': width}\">\n  <svg\n    [ngStyle]=\"{'width': width, 'height': height}\"\n    xmlns=\"http://www.w3.org/2000/svg\">\n    <!-- <path [attr.d]=\"pathD\" stroke=\"black\" fill=\"transparent\" stroke-width=\"8\" fill-opacity=\"0.5\"/> -->\n    <path\n      *ngFor=\"let arc of arcs\"\n      [attr.d]=\"arc.d\"\n      [attr.stroke]=\"arc.color\"\n      fill=\"transparent\"\n      [attr.stroke-width]=\"thickness\"\n      fill-opacity=\"0.5\"/>\n  </svg>\n\n  <div\n    class=\"c-donutchart__text\"\n    *ngIf=\"title\"\n    [ngStyle]=\"{'width': width, 'height': height}\">\n    <div\n      [ngClass]=\"totalClass\"\n      [innerText]=\"total\"></div>\n    <div [innerText]=\"title\"></div>\n  </div>\n\n  <div class=\"c-donutchart__legends\">\n    <div\n      class=\"c-donutchart__legend\"\n      *ngFor=\"let item of data\">\n      <div\n        class=\"c-donutchart__legend-bar\"\n        [ngStyle]=\"{'background-color': item.color}\">\n      </div>\n\n      <div\n        class=\"c-donutchart__legend-title\"\n        [innerText]=\"item.label\">\n      </div>\n\n      <div\n        class=\"c-donutchart__legend-percentage\"\n        [innerText]=\"item.percentage\">\n      </div>\n    </div>\n  </div>\n</div>\n",
                    styles: [".c-donutchart{position:relative}.c-donutchart .c-donutchart__text{position:absolute;top:0;left:0;display:flex;flex-flow:column;align-items:center;justify-content:center}.c-donutchart .c-donutchart__title{font-size:40px}.c-donutchart .c-donutchart__legends{display:flex;justify-content:center}.c-donutchart .c-donutchart__legend{display:flex;flex-flow:column;align-items:center;margin:16px 8px}.c-donutchart .c-donutchart__legend-bar{display:flex;align-items:center;justify-content:center;margin-bottom:8px;width:40px;height:8px;border-radius:4px;background-color:#dc143c}.c-donutchart .c-donutchart__legend-percentage,.c-donutchart .c-donutchart__legend-title{text-align:center}"]
                },] },
    ];
    /** @nocollapse */
    NgxDonutChartComponent.ctorParameters = function () { return []; };
    NgxDonutChartComponent.propDecorators = {
        data: [{ type: Input }],
        radius: [{ type: Input }],
        margin: [{ type: Input }],
        title: [{ type: Input }],
        thickness: [{ type: Input }],
        totalClass: [{ type: Input }]
    };
    return NgxDonutChartComponent;
}());
export { NgxDonutChartComponent };
if (false) {
    /** @type {?} */
    NgxDonutChartComponent.prototype.data;
    /** @type {?} */
    NgxDonutChartComponent.prototype.radius;
    /** @type {?} */
    NgxDonutChartComponent.prototype.margin;
    /** @type {?} */
    NgxDonutChartComponent.prototype.title;
    /** @type {?} */
    NgxDonutChartComponent.prototype.thickness;
    /** @type {?} */
    NgxDonutChartComponent.prototype.totalClass;
    /** @type {?} */
    NgxDonutChartComponent.prototype.width;
    /** @type {?} */
    NgxDonutChartComponent.prototype.height;
    /** @type {?} */
    NgxDonutChartComponent.prototype.origin;
    /** @type {?} */
    NgxDonutChartComponent.prototype.arcs;
    /** @type {?} */
    NgxDonutChartComponent.prototype.total;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWRvbnV0LWNoYXJ0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1kb3VnaG51dC1jaGFydC8iLCJzb3VyY2VzIjpbImxpYi9uZ3gtZG9udXQtY2hhcnQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBVSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7O0lBa0V2RDtLQUFpQjs7OztJQUVqQix5Q0FBUTs7O0lBQVI7UUFDRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7O1FBQ25CLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7O1FBQzlDLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDdEQ7Ozs7SUFFRCw0Q0FBVzs7O0lBQVg7UUFDRSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNmLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUM7UUFDakMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQztRQUNoQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFBSSxxQkFBcUIsQ0FBQztRQUMzRCxJQUFJLENBQUMsTUFBTSxHQUFHO1lBQ1osQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ2QsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNO1NBQ2YsQ0FBQztRQUNGLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1B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RCxDQUFDO0tBQ0g7O2dCQTNKRixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLGlCQUFpQjtvQkFDM0IsUUFBUSxFQUFFLHV2Q0ErQ1g7b0JBQ0MsTUFBTSxFQUFFLENBQUMsd3FCQUF3cUIsQ0FBQztpQkFDbnJCOzs7Ozt1QkFFRSxLQUFLO3lCQUNMLEtBQUs7eUJBQ0wsS0FBSzt3QkFDTCxLQUFLOzRCQUNMLEtBQUs7NkJBQ0wsS0FBSzs7aUNBNURSOztTQXNEYSxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LWRvbnV0LWNoYXJ0JyxcbiAgdGVtcGxhdGU6IGA8ZGl2XG4gIGNsYXNzPVwiYy1kb251dGNoYXJ0XCJcbiAgW25nU3R5bGVdPVwieyd3aWR0aCc6IHdpZHRofVwiPlxuICA8c3ZnXG4gICAgW25nU3R5bGVdPVwieyd3aWR0aCc6IHdpZHRoLCAnaGVpZ2h0JzogaGVpZ2h0fVwiXG4gICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgIDwhLS0gPHBhdGggW2F0dHIuZF09XCJwYXRoRFwiIHN0cm9rZT1cImJsYWNrXCIgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlLXdpZHRoPVwiOFwiIGZpbGwtb3BhY2l0eT1cIjAuNVwiLz4gLS0+XG4gICAgPHBhdGhcbiAgICAgICpuZ0Zvcj1cImxldCBhcmMgb2YgYXJjc1wiXG4gICAgICBbYXR0ci5kXT1cImFyYy5kXCJcbiAgICAgIFthdHRyLnN0cm9rZV09XCJhcmMuY29sb3JcIlxuICAgICAgZmlsbD1cInRyYW5zcGFyZW50XCJcbiAgICAgIFthdHRyLnN0cm9rZS13aWR0aF09XCJ0aGlja25lc3NcIlxuICAgICAgZmlsbC1vcGFjaXR5PVwiMC41XCIvPlxuICA8L3N2Zz5cblxuICA8ZGl2XG4gICAgY2xhc3M9XCJjLWRvbnV0Y2hhcnRfX3RleHRcIlxuICAgICpuZ0lmPVwidGl0bGVcIlxuICAgIFtuZ1N0eWxlXT1cInsnd2lkdGgnOiB3aWR0aCwgJ2hlaWdodCc6IGhlaWdodH1cIj5cbiAgICA8ZGl2XG4gICAgICBbbmdDbGFzc109XCJ0b3RhbENsYXNzXCJcbiAgICAgIFtpbm5lclRleHRdPVwidG90YWxcIj48L2Rpdj5cbiAgICA8ZGl2IFtpbm5lclRleHRdPVwidGl0bGVcIj48L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cImMtZG9udXRjaGFydF9fbGVnZW5kc1wiPlxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwiYy1kb251dGNoYXJ0X19sZWdlbmRcIlxuICAgICAgKm5nRm9yPVwibGV0IGl0ZW0gb2YgZGF0YVwiPlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzcz1cImMtZG9udXRjaGFydF9fbGVnZW5kLWJhclwiXG4gICAgICAgIFtuZ1N0eWxlXT1cInsnYmFja2dyb3VuZC1jb2xvcic6IGl0ZW0uY29sb3J9XCI+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdlxuICAgICAgICBjbGFzcz1cImMtZG9udXRjaGFydF9fbGVnZW5kLXRpdGxlXCJcbiAgICAgICAgW2lubmVyVGV4dF09XCJpdGVtLmxhYmVsXCI+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdlxuICAgICAgICBjbGFzcz1cImMtZG9udXRjaGFydF9fbGVnZW5kLXBlcmNlbnRhZ2VcIlxuICAgICAgICBbaW5uZXJUZXh0XT1cIml0ZW0ucGVyY2VudGFnZVwiPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG5gLFxuICBzdHlsZXM6IFtgLmMtZG9udXRjaGFydHtwb3NpdGlvbjpyZWxhdGl2ZX0uYy1kb251dGNoYXJ0IC5jLWRvbnV0Y2hhcnRfX3RleHR7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO2Rpc3BsYXk6ZmxleDtmbGV4LWZsb3c6Y29sdW1uO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5jLWRvbnV0Y2hhcnQgLmMtZG9udXRjaGFydF9fdGl0bGV7Zm9udC1zaXplOjQwcHh9LmMtZG9udXRjaGFydCAuYy1kb251dGNoYXJ0X19sZWdlbmRze2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5jLWRvbnV0Y2hhcnQgLmMtZG9udXRjaGFydF9fbGVnZW5ke2Rpc3BsYXk6ZmxleDtmbGV4LWZsb3c6Y29sdW1uO2FsaWduLWl0ZW1zOmNlbnRlcjttYXJnaW46MTZweCA4cHh9LmMtZG9udXRjaGFydCAuYy1kb251dGNoYXJ0X19sZWdlbmQtYmFye2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW4tYm90dG9tOjhweDt3aWR0aDo0MHB4O2hlaWdodDo4cHg7Ym9yZGVyLXJhZGl1czo0cHg7YmFja2dyb3VuZC1jb2xvcjojZGMxNDNjfS5jLWRvbnV0Y2hhcnQgLmMtZG9udXRjaGFydF9fbGVnZW5kLXBlcmNlbnRhZ2UsLmMtZG9udXRjaGFydCAuYy1kb251dGNoYXJ0X19sZWdlbmQtdGl0bGV7dGV4dC1hbGlnbjpjZW50ZXJ9YF1cbn0pXG5leHBvcnQgY2xhc3MgTmd4RG9udXRDaGFydENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgpIGRhdGE6IFt7YW55fV07XG4gIEBJbnB1dCgpIHJhZGl1czogbnVtYmVyO1xuICBASW5wdXQoKSBtYXJnaW46IG51bWJlcjtcbiAgQElucHV0KCkgdGl0bGU6IHN0cmluZztcbiAgQElucHV0KCkgdGhpY2tuZXNzOiBudW1iZXI7XG4gIEBJbnB1dCgpIHRvdGFsQ2xhc3M6IHN0cmluZztcbiAgd2lkdGg6IHN0cmluZztcbiAgaGVpZ2h0OiBzdHJpbmc7XG4gIG9yaWdpbjoge3g6IG51bWJlciwgeTogbnVtYmVyfTtcbiAgYXJjczogYW55W107XG4gIHRvdGFsOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKCkgeyB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zZXREZWZhdWx0cygpO1xuICAgIGxldCBhbmdsZXMgPSB0aGlzLl9jYWxjdWxhdGVBbmdsZXModGhpcy5kYXRhKTtcbiAgICBsZXQgQXJjaFBvaW50cyA9IHRoaXMuX2NhbGN1bGF0ZUFyY1BvaW50cyh0aGlzLmRhdGEpO1xuICB9XG5cbiAgc2V0RGVmYXVsdHMoKSB7XG4gICAgdGhpcy5hcmNzID0gW107XG4gICAgdGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyB8fCAyMDA7XG4gICAgdGhpcy5tYXJnaW4gPSB0aGlzLm1hcmdpbiB8fCAxMDtcbiAgICB0aGlzLnRoaWNrbmVzcyA9IHRoaXMudGhpY2tuZXNzIHx8IDg7XG4gICAgdGhpcy50b3RhbENsYXNzID0gdGhpcy50b3RhbENsYXNzIHx8ICdjLWRvbnV0Y2hhcnRfX3RpdGxlJztcbiAgICB0aGlzLm9yaWdpbiA9IHtcbiAgICAgIHg6IHRoaXMucmFkaXVzLFxuICAgICAgeTogdGhpcy5yYWRpdXMsXG4gICAgfTtcbiAgICB0aGlzLndpZHRoID0gKCgyICogdGhpcy5yYWRpdXMpICsgKDIgKiB0aGlzLm1hcmdpbikpICsgJ3B4JztcbiAgICB0aGlzLmhlaWdodCA9ICgoMiAqIHRoaXMucmFkaXVzKSArICgyICogdGhpcy5tYXJnaW4pKSArICdweCc7XG4gIH1cblxuICBfY2FsY3VsYXRlQXJjUG9pbnRzKGRhdGEpIHtcbiAgICBsZXQgYXJjaFBvaW50cyA9IFtdO1xuICAgIGFyY2hQb2ludHMucHVzaCh7XG4gICAgICB4OiB0aGlzLnJhZGl1cyxcbiAgICAgIHk6IDAsXG4gICAgfSk7XG5cbiAgICBsZXQgc3RhcnRBbmdsZSA9IDA7XG4gICAgbGV0IGVuZEFuZ2xlO1xuICAgIGxldCBzdGFydFggPSB0aGlzLm9yaWdpbi54O1xuICAgIGxldCBzdGFydFkgPSB0aGlzLm9yaWdpbi55O1xuXG4gICAgZm9yIChsZXQgaXRlbSBvZiBkYXRhKSB7XG4gICAgICBlbmRBbmdsZSA9IChzdGFydEFuZ2xlICsgaXRlbS5hbmdsZSkgJSAzNjA7XG4gICAgICBzdGFydEFuZ2xlICs9IDg7XG4gICAgICAvLyBlbmRBbmdsZSAtPTU7XG5cbiAgICAgIGxldCBhcmMgPSB0aGlzLl9kZXNjcmliZUFyYyhzdGFydFgsIHN0YXJ0WSwgdGhpcy5yYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpdGVtLmNvbG9yKTtcbiAgICAgIHRoaXMuYXJjcy5wdXNoKGFyYyk7XG5cbiAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZTtcbiAgICB9XG4gIH1cblxuICBfZGVzY3JpYmVBcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY29sb3Ipe1xuICAgIGxldCBzdGFydCA9IHRoaXMuX3BvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgICBsZXQgZW5kID0gdGhpcy5fcG9sYXJUb0NhcnRlc2lhbih4LCB5LCByYWRpdXMsIGVuZEFuZ2xlKTtcbiAgICBsZXQgYXJjU3dlZXAgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPD0gMTgwID8gXCIwXCIgOiBcIjFcIjtcblxuICAgIGxldCBkID0gW1xuICAgICAgICBcIk1cIiwgc3RhcnQueCwgc3RhcnQueSxcbiAgICAgICAgXCJBXCIsIHJhZGl1cywgcmFkaXVzLCAwLCBhcmNTd2VlcCwgMSwgZW5kLngsIGVuZC55LFxuICAgICAgICAvLyBcIkxcIiwgeCx5LFxuICAgICAgICAvLyBcIkxcIiwgc3RhcnQueCwgc3RhcnQueVxuICAgIF0uam9pbihcIiBcIik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZDogZCxcbiAgICAgIGVuZDogZW5kLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgIH07XG4gIH1cblxuICBfY2FsY3VsYXRlQW5nbGVzKGRhdGEpIHtcbiAgICBsZXQgYW5nbGVzID0gW107XG4gICAgbGV0IHRvdGFsID0gdGhpcy5fZ2V0VG90YWwoZGF0YSk7XG4gICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZGF0YUl0ZW0gPSBkYXRhW2ldO1xuICAgICAgbGV0IGFuZ2xlID0gKGRhdGFJdGVtLnZhbHVlIC8gdG90YWwpICogMzYwLjA7XG4gICAgICBkYXRhSXRlbS5hbmdsZSA9IGFuZ2xlO1xuICAgICAgZGF0YUl0ZW0ucGVyY2VudGFnZSA9ICgoZGF0YUl0ZW0udmFsdWUgLyB0b3RhbCkgKiAxMDAuMCkudG9GaXhlZCgyKSArICclJztcbiAgICAgIGFuZ2xlcy5wdXNoKGFuZ2xlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5nbGVzO1xuICB9XG5cbiAgX2dldFRvdGFsKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yZWR1Y2UoKGEsIGIpID0+ICh7IHZhbHVlIDogYS52YWx1ZSArIGIudmFsdWUgfSkpLnZhbHVlO1xuICB9XG5cbiAgX3BvbGFyVG9DYXJ0ZXNpYW4oY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBhbmdsZUluRGVncmVlcykge1xuICAgIGxldCBhbmdsZUluUmFkaWFucyA9IChhbmdsZUluRGVncmVlcykgKiBNYXRoLlBJIC8gMTgwLjA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogY2VudGVyWCArIChyYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucykpICsgdGhpcy5tYXJnaW4sXG4gICAgICB5OiBjZW50ZXJZICsgKHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKSkgKyB0aGlzLm1hcmdpbixcbiAgICB9O1xuICB9XG5cbn1cbiJdfQ==
import { Injectable, NgModule, Component, Input, defineInjectable } from '@angular/core';
import { __values } from 'tslib';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgxDonutChartService = /** @class */ (function () {
    function NgxDonutChartService() {
    }
    NgxDonutChartService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */
    NgxDonutChartService.ctorParameters = function () { return []; };
    /** @nocollapse */ NgxDonutChartService.ngInjectableDef = defineInjectable({ factory: function NgxDonutChartService_Factory() { return new NgxDonutChartService(); }, token: NgxDonutChartService, providedIn: "root" });
    return NgxDonutChartService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgxDonutChartComponent = /** @class */ (function () {
    function NgxDonutChartComponent() {
    }
    /**
     * @return {?}
     */
    NgxDonutChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setDefaults();
        /** @type {?} */
        var angles = this._calculateAngles(this.data);
        /** @type {?} */
        var ArchPoints = this._calculateArcPoints(this.data);
    };
    /**
     * @return {?}
     */
    NgxDonutChartComponent.prototype.setDefaults = /**
     * @return {?}
     */
    function () {
        this.arcs = [];
        this.radius = this.radius || 200;
        this.margin = this.margin || 10;
        this.thickness = this.thickness || 8;
        this.totalClass = this.totalClass || 'c-donutchart__title';
        this.origin = {
            x: this.radius,
            y: this.radius,
        };
        this.width = ((2 * this.radius) + (2 * this.margin)) + 'px';
        this.height = ((2 * this.radius) + (2 * this.margin)) + 'px';
    };
    /**
     * @param {?} data
     * @return {?}
     */
    NgxDonutChartComponent.prototype._calculateArcPoints = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var archPoints = [];
        archPoints.push({
            x: this.radius,
            y: 0,
        });
        /** @type {?} */
        var startAngle = 0;
        /** @type {?} */
        var endAngle;
        /** @type {?} */
        var startX = this.origin.x;
        /** @type {?} */
        var startY = this.origin.y;
        try {
            for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var item = data_1_1.value;
                endAngle = (startAngle + item.angle) % 360;
                startAngle += 8;
                /** @type {?} */
                var arc = this._describeArc(startX, startY, this.radius, startAngle, endAngle, item.color);
                this.arcs.push(arc);
                startAngle = endAngle;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var e_1, _a;
    };
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} radius
     * @param {?} startAngle
     * @param {?} endAngle
     * @param {?} color
     * @return {?}
     */
    NgxDonutChartComponent.prototype._describeArc = /**
     * @param {?} x
     * @param {?} y
     * @param {?} radius
     * @param {?} startAngle
     * @param {?} endAngle
     * @param {?} color
     * @return {?}
     */
    function (x, y, radius, startAngle, endAngle, color) {
        /** @type {?} */
        var start = this._polarToCartesian(x, y, radius, startAngle);
        /** @type {?} */
        var end = this._polarToCartesian(x, y, radius, endAngle);
        /** @type {?} */
        var arcSweep = endAngle - startAngle <= 180 ? "0" : "1";
        /** @type {?} */
        var d = [
            "M", start.x, start.y,
            "A", radius, radius, 0, arcSweep, 1, end.x, end.y,
        ].join(" ");
        return {
            d: d,
            end: end,
            color: color,
        };
    };
    /**
     * @param {?} data
     * @return {?}
     */
    NgxDonutChartComponent.prototype._calculateAngles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var angles = [];
        /** @type {?} */
        var total = this._getTotal(data);
        this.total = total;
        for (var i = 0; i < data.length; i++) {
            /** @type {?} */
            var dataItem = data[i];
            /** @type {?} */
            var angle = (dataItem.value / total) * 360.0;
            dataItem.angle = angle;
            dataItem.percentage = ((dataItem.value / total) * 100.0).toFixed(2) + '%';
            angles.push(angle);
        }
        return angles;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    NgxDonutChartComponent.prototype._getTotal = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.reduce(function (a, b) { return ({ value: a.value + b.value }); }).value;
    };
    /**
     * @param {?} centerX
     * @param {?} centerY
     * @param {?} radius
     * @param {?} angleInDegrees
     * @return {?}
     */
    NgxDonutChartComponent.prototype._polarToCartesian = /**
     * @param {?} centerX
     * @param {?} centerY
     * @param {?} radius
     * @param {?} angleInDegrees
     * @return {?}
     */
    function (centerX, centerY, radius, angleInDegrees) {
        /** @type {?} */
        var angleInRadians = (angleInDegrees) * Math.PI / 180.0;
        return {
            x: centerX + (radius * Math.cos(angleInRadians)) + this.margin,
            y: centerY + (radius * Math.sin(angleInRadians)) + this.margin,
        };
    };
    NgxDonutChartComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-donut-chart',
                    template: "<div\n  class=\"c-donutchart\"\n  [ngStyle]=\"{'width': width}\">\n  <svg\n    [ngStyle]=\"{'width': width, 'height': height}\"\n    xmlns=\"http://www.w3.org/2000/svg\">\n    <!-- <path [attr.d]=\"pathD\" stroke=\"black\" fill=\"transparent\" stroke-width=\"8\" fill-opacity=\"0.5\"/> -->\n    <path\n      *ngFor=\"let arc of arcs\"\n      [attr.d]=\"arc.d\"\n      [attr.stroke]=\"arc.color\"\n      fill=\"transparent\"\n      [attr.stroke-width]=\"thickness\"\n      fill-opacity=\"0.5\"/>\n  </svg>\n\n  <div\n    class=\"c-donutchart__text\"\n    *ngIf=\"title\"\n    [ngStyle]=\"{'width': width, 'height': height}\">\n    <div\n      [ngClass]=\"totalClass\"\n      [innerText]=\"total\"></div>\n    <div [innerText]=\"title\"></div>\n  </div>\n\n  <div class=\"c-donutchart__legends\">\n    <div\n      class=\"c-donutchart__legend\"\n      *ngFor=\"let item of data\">\n      <div\n        class=\"c-donutchart__legend-bar\"\n        [ngStyle]=\"{'background-color': item.color}\">\n      </div>\n\n      <div\n        class=\"c-donutchart__legend-title\"\n        [innerText]=\"item.label\">\n      </div>\n\n      <div\n        class=\"c-donutchart__legend-percentage\"\n        [innerText]=\"item.percentage\">\n      </div>\n    </div>\n  </div>\n</div>\n",
                    styles: [".c-donutchart{position:relative}.c-donutchart .c-donutchart__text{position:absolute;top:0;left:0;display:flex;flex-flow:column;align-items:center;justify-content:center}.c-donutchart .c-donutchart__title{font-size:40px}.c-donutchart .c-donutchart__legends{display:flex;justify-content:center}.c-donutchart .c-donutchart__legend{display:flex;flex-flow:column;align-items:center;margin:16px 8px}.c-donutchart .c-donutchart__legend-bar{display:flex;align-items:center;justify-content:center;margin-bottom:8px;width:40px;height:8px;border-radius:4px;background-color:#dc143c}.c-donutchart .c-donutchart__legend-percentage,.c-donutchart .c-donutchart__legend-title{text-align:center}"]
                },] },
    ];
    /** @nocollapse */
    NgxDonutChartComponent.ctorParameters = function () { return []; };
    NgxDonutChartComponent.propDecorators = {
        data: [{ type: Input }],
        radius: [{ type: Input }],
        margin: [{ type: Input }],
        title: [{ type: Input }],
        thickness: [{ type: Input }],
        totalClass: [{ type: Input }]
    };
    return NgxDonutChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgxDonutChartModule = /** @class */ (function () {
    function NgxDonutChartModule() {
    }
    NgxDonutChartModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [NgxDonutChartComponent],
                    exports: [NgxDonutChartComponent]
                },] },
    ];
    return NgxDonutChartModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgxDonutChartService, NgxDonutChartComponent, NgxDonutChartModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWRvdWdobnV0LWNoYXJ0LmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9uZ3gtZG91Z2hudXQtY2hhcnQvbGliL25neC1kb251dC1jaGFydC5zZXJ2aWNlLnRzIiwibmc6Ly9uZ3gtZG91Z2hudXQtY2hhcnQvbGliL25neC1kb251dC1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL25neC1kb3VnaG51dC1jaGFydC9saWIvbmd4LWRvbnV0LWNoYXJ0Lm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIE5neERvbnV0Q2hhcnRTZXJ2aWNlIHtcblxuICBjb25zdHJ1Y3RvcigpIHsgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25neC1kb251dC1jaGFydCcsXG4gIHRlbXBsYXRlOiBgPGRpdlxuICBjbGFzcz1cImMtZG9udXRjaGFydFwiXG4gIFtuZ1N0eWxlXT1cInsnd2lkdGgnOiB3aWR0aH1cIj5cbiAgPHN2Z1xuICAgIFtuZ1N0eWxlXT1cInsnd2lkdGgnOiB3aWR0aCwgJ2hlaWdodCc6IGhlaWdodH1cIlxuICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICA8IS0tIDxwYXRoIFthdHRyLmRdPVwicGF0aERcIiBzdHJva2U9XCJibGFja1wiIGZpbGw9XCJ0cmFuc3BhcmVudFwiIHN0cm9rZS13aWR0aD1cIjhcIiBmaWxsLW9wYWNpdHk9XCIwLjVcIi8+IC0tPlxuICAgIDxwYXRoXG4gICAgICAqbmdGb3I9XCJsZXQgYXJjIG9mIGFyY3NcIlxuICAgICAgW2F0dHIuZF09XCJhcmMuZFwiXG4gICAgICBbYXR0ci5zdHJva2VdPVwiYXJjLmNvbG9yXCJcbiAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXG4gICAgICBbYXR0ci5zdHJva2Utd2lkdGhdPVwidGhpY2tuZXNzXCJcbiAgICAgIGZpbGwtb3BhY2l0eT1cIjAuNVwiLz5cbiAgPC9zdmc+XG5cbiAgPGRpdlxuICAgIGNsYXNzPVwiYy1kb251dGNoYXJ0X190ZXh0XCJcbiAgICAqbmdJZj1cInRpdGxlXCJcbiAgICBbbmdTdHlsZV09XCJ7J3dpZHRoJzogd2lkdGgsICdoZWlnaHQnOiBoZWlnaHR9XCI+XG4gICAgPGRpdlxuICAgICAgW25nQ2xhc3NdPVwidG90YWxDbGFzc1wiXG4gICAgICBbaW5uZXJUZXh0XT1cInRvdGFsXCI+PC9kaXY+XG4gICAgPGRpdiBbaW5uZXJUZXh0XT1cInRpdGxlXCI+PC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxkaXYgY2xhc3M9XCJjLWRvbnV0Y2hhcnRfX2xlZ2VuZHNcIj5cbiAgICA8ZGl2XG4gICAgICBjbGFzcz1cImMtZG9udXRjaGFydF9fbGVnZW5kXCJcbiAgICAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGRhdGFcIj5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJjLWRvbnV0Y2hhcnRfX2xlZ2VuZC1iYXJcIlxuICAgICAgICBbbmdTdHlsZV09XCJ7J2JhY2tncm91bmQtY29sb3InOiBpdGVtLmNvbG9yfVwiPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJjLWRvbnV0Y2hhcnRfX2xlZ2VuZC10aXRsZVwiXG4gICAgICAgIFtpbm5lclRleHRdPVwiaXRlbS5sYWJlbFwiPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJjLWRvbnV0Y2hhcnRfX2xlZ2VuZC1wZXJjZW50YWdlXCJcbiAgICAgICAgW2lubmVyVGV4dF09XCJpdGVtLnBlcmNlbnRhZ2VcIj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgc3R5bGVzOiBbYC5jLWRvbnV0Y2hhcnR7cG9zaXRpb246cmVsYXRpdmV9LmMtZG9udXRjaGFydCAuYy1kb251dGNoYXJ0X190ZXh0e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtkaXNwbGF5OmZsZXg7ZmxleC1mbG93OmNvbHVtbjthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uYy1kb251dGNoYXJ0IC5jLWRvbnV0Y2hhcnRfX3RpdGxle2ZvbnQtc2l6ZTo0MHB4fS5jLWRvbnV0Y2hhcnQgLmMtZG9udXRjaGFydF9fbGVnZW5kc3tkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uYy1kb251dGNoYXJ0IC5jLWRvbnV0Y2hhcnRfX2xlZ2VuZHtkaXNwbGF5OmZsZXg7ZmxleC1mbG93OmNvbHVtbjthbGlnbi1pdGVtczpjZW50ZXI7bWFyZ2luOjE2cHggOHB4fS5jLWRvbnV0Y2hhcnQgLmMtZG9udXRjaGFydF9fbGVnZW5kLWJhcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luLWJvdHRvbTo4cHg7d2lkdGg6NDBweDtoZWlnaHQ6OHB4O2JvcmRlci1yYWRpdXM6NHB4O2JhY2tncm91bmQtY29sb3I6I2RjMTQzY30uYy1kb251dGNoYXJ0IC5jLWRvbnV0Y2hhcnRfX2xlZ2VuZC1wZXJjZW50YWdlLC5jLWRvbnV0Y2hhcnQgLmMtZG9udXRjaGFydF9fbGVnZW5kLXRpdGxle3RleHQtYWxpZ246Y2VudGVyfWBdXG59KVxuZXhwb3J0IGNsYXNzIE5neERvbnV0Q2hhcnRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICBASW5wdXQoKSBkYXRhOiBbe2FueX1dO1xuICBASW5wdXQoKSByYWRpdXM6IG51bWJlcjtcbiAgQElucHV0KCkgbWFyZ2luOiBudW1iZXI7XG4gIEBJbnB1dCgpIHRpdGxlOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHRoaWNrbmVzczogbnVtYmVyO1xuICBASW5wdXQoKSB0b3RhbENsYXNzOiBzdHJpbmc7XG4gIHdpZHRoOiBzdHJpbmc7XG4gIGhlaWdodDogc3RyaW5nO1xuICBvcmlnaW46IHt4OiBudW1iZXIsIHk6IG51bWJlcn07XG4gIGFyY3M6IGFueVtdO1xuICB0b3RhbDogbnVtYmVyO1xuICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc2V0RGVmYXVsdHMoKTtcbiAgICBsZXQgYW5nbGVzID0gdGhpcy5fY2FsY3VsYXRlQW5nbGVzKHRoaXMuZGF0YSk7XG4gICAgbGV0IEFyY2hQb2ludHMgPSB0aGlzLl9jYWxjdWxhdGVBcmNQb2ludHModGhpcy5kYXRhKTtcbiAgfVxuXG4gIHNldERlZmF1bHRzKCkge1xuICAgIHRoaXMuYXJjcyA9IFtdO1xuICAgIHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgfHwgMjAwO1xuICAgIHRoaXMubWFyZ2luID0gdGhpcy5tYXJnaW4gfHwgMTA7XG4gICAgdGhpcy50aGlja25lc3MgPSB0aGlzLnRoaWNrbmVzcyB8fCA4O1xuICAgIHRoaXMudG90YWxDbGFzcyA9IHRoaXMudG90YWxDbGFzcyB8fCAnYy1kb251dGNoYXJ0X190aXRsZSc7XG4gICAgdGhpcy5vcmlnaW4gPSB7XG4gICAgICB4OiB0aGlzLnJhZGl1cyxcbiAgICAgIHk6IHRoaXMucmFkaXVzLFxuICAgIH07XG4gICAgdGhpcy53aWR0aCA9ICgoMiAqIHRoaXMucmFkaXVzKSArICgyICogdGhpcy5tYXJnaW4pKSArICdweCc7XG4gICAgdGhpcy5oZWlnaHQgPSAoKDIgKiB0aGlzLnJhZGl1cykgKyAoMiAqIHRoaXMubWFyZ2luKSkgKyAncHgnO1xuICB9XG5cbiAgX2NhbGN1bGF0ZUFyY1BvaW50cyhkYXRhKSB7XG4gICAgbGV0IGFyY2hQb2ludHMgPSBbXTtcbiAgICBhcmNoUG9pbnRzLnB1c2goe1xuICAgICAgeDogdGhpcy5yYWRpdXMsXG4gICAgICB5OiAwLFxuICAgIH0pO1xuXG4gICAgbGV0IHN0YXJ0QW5nbGUgPSAwO1xuICAgIGxldCBlbmRBbmdsZTtcbiAgICBsZXQgc3RhcnRYID0gdGhpcy5vcmlnaW4ueDtcbiAgICBsZXQgc3RhcnRZID0gdGhpcy5vcmlnaW4ueTtcblxuICAgIGZvciAobGV0IGl0ZW0gb2YgZGF0YSkge1xuICAgICAgZW5kQW5nbGUgPSAoc3RhcnRBbmdsZSArIGl0ZW0uYW5nbGUpICUgMzYwO1xuICAgICAgc3RhcnRBbmdsZSArPSA4O1xuICAgICAgLy8gZW5kQW5nbGUgLT01O1xuXG4gICAgICBsZXQgYXJjID0gdGhpcy5fZGVzY3JpYmVBcmMoc3RhcnRYLCBzdGFydFksIHRoaXMucmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaXRlbS5jb2xvcik7XG4gICAgICB0aGlzLmFyY3MucHVzaChhcmMpO1xuXG4gICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgfVxuICB9XG5cbiAgX2Rlc2NyaWJlQXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvbG9yKXtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLl9wb2xhclRvQ2FydGVzaWFuKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSk7XG4gICAgbGV0IGVuZCA9IHRoaXMuX3BvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBlbmRBbmdsZSk7XG4gICAgbGV0IGFyY1N3ZWVwID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlIDw9IDE4MCA/IFwiMFwiIDogXCIxXCI7XG5cbiAgICBsZXQgZCA9IFtcbiAgICAgICAgXCJNXCIsIHN0YXJ0LngsIHN0YXJ0LnksXG4gICAgICAgIFwiQVwiLCByYWRpdXMsIHJhZGl1cywgMCwgYXJjU3dlZXAsIDEsIGVuZC54LCBlbmQueSxcbiAgICAgICAgLy8gXCJMXCIsIHgseSxcbiAgICAgICAgLy8gXCJMXCIsIHN0YXJ0LngsIHN0YXJ0LnlcbiAgICBdLmpvaW4oXCIgXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGQ6IGQsXG4gICAgICBlbmQ6IGVuZCxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICB9O1xuICB9XG5cbiAgX2NhbGN1bGF0ZUFuZ2xlcyhkYXRhKSB7XG4gICAgbGV0IGFuZ2xlcyA9IFtdO1xuICAgIGxldCB0b3RhbCA9IHRoaXMuX2dldFRvdGFsKGRhdGEpO1xuICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGRhdGFJdGVtID0gZGF0YVtpXTtcbiAgICAgIGxldCBhbmdsZSA9IChkYXRhSXRlbS52YWx1ZSAvIHRvdGFsKSAqIDM2MC4wO1xuICAgICAgZGF0YUl0ZW0uYW5nbGUgPSBhbmdsZTtcbiAgICAgIGRhdGFJdGVtLnBlcmNlbnRhZ2UgPSAoKGRhdGFJdGVtLnZhbHVlIC8gdG90YWwpICogMTAwLjApLnRvRml4ZWQoMikgKyAnJSc7XG4gICAgICBhbmdsZXMucHVzaChhbmdsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuZ2xlcztcbiAgfVxuXG4gIF9nZXRUb3RhbChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucmVkdWNlKChhLCBiKSA9PiAoeyB2YWx1ZSA6IGEudmFsdWUgKyBiLnZhbHVlIH0pKS52YWx1ZTtcbiAgfVxuXG4gIF9wb2xhclRvQ2FydGVzaWFuKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgYW5nbGVJbkRlZ3JlZXMpIHtcbiAgICBsZXQgYW5nbGVJblJhZGlhbnMgPSAoYW5nbGVJbkRlZ3JlZXMpICogTWF0aC5QSSAvIDE4MC4wO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGNlbnRlclggKyAocmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpKSArIHRoaXMubWFyZ2luLFxuICAgICAgeTogY2VudGVyWSArIChyYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucykpICsgdGhpcy5tYXJnaW4sXG4gICAgfTtcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgTmd4RG9udXRDaGFydENvbXBvbmVudCB9IGZyb20gJy4vbmd4LWRvbnV0LWNoYXJ0LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGVcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbTmd4RG9udXRDaGFydENvbXBvbmVudF0sXG4gIGV4cG9ydHM6IFtOZ3hEb251dENoYXJ0Q29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBOZ3hEb251dENoYXJ0TW9kdWxlIHsgfVxuIl0sIm5hbWVzIjpbInRzbGliXzEuX192YWx1ZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7SUFPRTtLQUFpQjs7Z0JBTGxCLFVBQVUsU0FBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7Ozs7OytCQUpEOzs7Ozs7OztJQ2tFRTtLQUFpQjs7OztJQUVqQix5Q0FBUTs7O0lBQVI7UUFDRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7O1FBQ25CLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7O1FBQzlDLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDdEQ7Ozs7SUFFRCw0Q0FBVzs7O0lBQVg7UUFDRSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNmLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUM7UUFDakMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQztRQUNoQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFB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